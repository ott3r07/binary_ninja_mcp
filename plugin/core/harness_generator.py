# plugin/core/harness_generator.py

from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
import json
from .input_analyzer import InputSpec, StructField

class HarnessType(Enum):
    """Types of fuzzing harnesses"""
    KERNEL_MODULE = "kernel"
    USERSPACE = "userspace"
    DRIVER = "driver"
    UEFI = "uefi"

@dataclass
class HarnessConfig:
    """Configuration for harness generation"""
    target_function: str
    target_address: int
    input_spec: InputSpec
    harness_type: HarnessType

    # Optional customizations
    custom_setup: Optional[str] = None
    custom_cleanup: Optional[str] = None
    timeout_ms: int = 1000
    max_input_size: int = 4096
    enable_asan: bool = False
    enable_kasan: bool = True

    # kAFL specific
    kafl_workdir: str = "/tmp/kafl_workdir"
    kafl_sharedir: str = "/dev/shm/kafl_sharedir"

class HarnessGenerator:
    """Generates kAFL-compatible fuzzing harnesses"""

    def __init__(self, bv):
        self.bv = bv

    def generate_harness(self, config: HarnessConfig) -> Dict[str, str]:
        """Generate complete harness with all supporting files"""

        files = {}

        # Generate main harness C file
        files['harness.c'] = self._generate_harness_c(config)

        # Generate header file if needed
        if config.input_spec.structure:
            files['input_types.h'] = self._generate_types_header(config)

        # Generate kAFL user API header
        files['kafl_user.h'] = self._generate_kafl_user_header(config)

        # Generate build files
        files['Makefile'] = self._generate_makefile(config)
        files['CMakeLists.txt'] = self._generate_cmake(config)

        # Generate kAFL config
        files['kafl.yaml'] = self._generate_kafl_config(config)

        # Generate documentation
        files['README.md'] = self._generate_readme(config)

        # Generate helper scripts
        files['run_fuzzer.sh'] = self._generate_run_script(config)
        files['setup_vm.sh'] = self._generate_vm_setup_script(config)

        return files

    def _generate_harness_c(self, config: HarnessConfig) -> str:
        """Generate main harness C code"""

        includes = self._generate_includes(config)
        globals_def = self._generate_globals(config)
        setup_func = self._generate_setup_code(config)
        fuzz_func = self._generate_fuzzing_function(config)
        main_func = self._generate_main_function(config)

        return f'''/*
 * kAFL Fuzzing Harness for {config.target_function}
 * Auto-generated by Binary Ninja MCP Fuzzing Extension
 *
 * Target: {config.target_function} @ {hex(config.target_address)}
 * Type: {config.harness_type.value}
 */

{includes}

{globals_def}

{setup_func}

{fuzz_func}

{main_func}
'''

    def _generate_includes(self, config: HarnessConfig) -> str:
        """Generate necessary includes"""
        includes = [
            '#include <stdint.h>',
            '#include <stddef.h>',
            '#include <string.h>',
            '#include <stdbool.h>',
            '#include "kafl_user.h"',
        ]

        if config.input_spec.structure:
            includes.append('#include "input_types.h"')

        if config.harness_type == HarnessType.KERNEL_MODULE:
            includes.extend([
                '#include <linux/module.h>',
                '#include <linux/kernel.h>',
                '#include <linux/init.h>',
                '#include <linux/slab.h>',
            ])

        return '\n'.join(includes)

    def _generate_globals(self, config: HarnessConfig) -> str:
        """Generate global state variables"""
        return f'''
// Global configuration
#define MAX_INPUT_SIZE {config.max_input_size}
#define TARGET_FUNCTION_ADDR {hex(config.target_address)}
#define TIMEOUT_MS {config.timeout_ms}

// Shared memory for kAFL communication
static uint8_t *payload_buffer = NULL;
static volatile uint32_t *payload_size_ptr = NULL;

// Target function pointer
typedef void (*target_func_t)(uint8_t *data, size_t size);
static target_func_t target_function = (target_func_t)TARGET_FUNCTION_ADDR;

// Fuzzing statistics
static uint64_t iteration_count = 0;
'''

    def _generate_setup_code(self, config: HarnessConfig) -> str:
        """Generate initialization code"""

        custom_setup = config.custom_setup if config.custom_setup else "// No custom setup"

        kasan_setup = ""
        if config.enable_kasan:
            kasan_setup = '''
    // Submit KASAN address for crash detection
    kAFL_hypercall(HYPERCALL_KAFL_SUBMIT_KASAN, 0);
'''

        return f'''
/**
 * Initialize the fuzzing harness
 * Called once before fuzzing begins
 */
static int harness_init(void) {{
    // Acquire control from kAFL
    kAFL_hypercall(HYPERCALL_KAFL_ACQUIRE, 0);

    // Get shared payload buffer
    payload_buffer = (uint8_t *)kAFL_hypercall(HYPERCALL_KAFL_GET_PAYLOAD, 0);
    if (!payload_buffer) {{
        return -1;
    }}

    // Submit CR3 value for Intel PT tracing
    uint64_t cr3;
    __asm__ __volatile__("mov %%cr3, %0" : "=r"(cr3));
    kAFL_hypercall(HYPERCALL_KAFL_SUBMIT_CR3, cr3);
{kasan_setup}
    // Submit panic handler address
    extern void kafl_panic_handler(void);
    kAFL_hypercall(HYPERCALL_KAFL_SUBMIT_PANIC, (uint64_t)kafl_panic_handler);

    // Custom initialization
{custom_setup}

    return 0;
}}
'''

    def _generate_fuzzing_function(self, config: HarnessConfig) -> str:
        """Generate main fuzzing iteration function"""

        input_prep = self._generate_input_preparation(config)
        target_invocation = self._generate_target_invocation(config)
        cleanup = config.custom_cleanup if config.custom_cleanup else "// No cleanup needed"

        return f'''
/**
 * Execute one fuzzing iteration
 * Called for each test case from kAFL
 */
static void harness_fuzz(uint8_t *input, size_t input_size) {{
    // Validate input size
    if (input_size == 0 || input_size > MAX_INPUT_SIZE) {{
        return;
    }}

    // Mark the start of interesting code region
    kAFL_hypercall(HYPERCALL_KAFL_RANGE_SUBMIT, TARGET_FUNCTION_ADDR);

{input_prep}

    // Execute target function
{target_invocation}

    // Mark end of interesting region
    kAFL_hypercall(HYPERCALL_KAFL_RANGE_SUBMIT, 0);

{cleanup}

    iteration_count++;
}}
'''

    def _generate_input_preparation(self, config: HarnessConfig) -> str:
        """Generate code to prepare input for target"""
        spec = config.input_spec

        if spec.input_type == "struct" and spec.structure:
            # Need to cast buffer to structure
            struct_name = "input_struct"
            return f'''    // Cast input buffer to target structure
    if (input_size < sizeof({struct_name})) {{
        return;  // Input too small
    }}

    {struct_name} *parsed_input = ({struct_name} *)input;

    // Validate magic values if required
{self._generate_constraint_checks(config)}
'''
        elif spec.input_type == "buffer":
            return '''    // Input is already in buffer format
    uint8_t *buffer = input;
    size_t buffer_size = input_size;
'''
        else:
            return '''    // Generic input handling
    void *prepared_input = input;
'''

    def _generate_constraint_checks(self, config: HarnessConfig) -> str:
        """Generate validation code for constraints"""
        checks = []

        for constraint in config.input_spec.constraints:
            if constraint.type.value == "magic":
                if constraint.offset is not None and constraint.value is not None:
                    checks.append(f'''    if (*(uint32_t*)(input + {constraint.offset}) != {hex(constraint.value)}) {{
        return;  // Magic value mismatch
    }}''')

            elif constraint.type.value == "length":
                if constraint.max_value:
                    checks.append(f'''    if (input_size > {constraint.max_value}) {{
        return;  // Input too large
    }}''')

        return '\n'.join(checks) if checks else '    // No constraints to check'

    def _generate_target_invocation(self, config: HarnessConfig) -> str:
        """Generate code to call target function"""
        return '''        // Invoke target function
        target_function(input, input_size);
'''

    def _generate_main_function(self, config: HarnessConfig) -> str:
        """Generate main fuzzing loop"""

        if config.harness_type == HarnessType.KERNEL_MODULE:
            return self._generate_kernel_module_main(config)
        else:
            return self._generate_userspace_main(config)

    def _generate_userspace_main(self, config: HarnessConfig) -> str:
        """Generate main() for userspace harness"""
        return '''
/**
 * Main fuzzing loop
 */
int main(int argc, char **argv) {
    // Initialize harness
    if (harness_init() != 0) {
        return 1;
    }

    // Main fuzzing loop
    while (1) {
        // Request next payload from kAFL
        kAFL_hypercall(HYPERCALL_KAFL_NEXT_PAYLOAD, 0);

        // Get payload size
        uint32_t payload_size = kAFL_hypercall(HYPERCALL_KAFL_GET_PAYLOAD_SIZE, 0);

        // Execute fuzzing iteration
        harness_fuzz(payload_buffer, payload_size);

        // Signal completion to kAFL
        kAFL_hypercall(HYPERCALL_KAFL_RELEASE, 0);
    }

    return 0;
}

/**
 * Panic handler for crash detection
 */
void kafl_panic_handler(void) {
    kAFL_hypercall(HYPERCALL_KAFL_PANIC, iteration_count);
}
'''

    def _generate_kernel_module_main(self, config: HarnessConfig) -> str:
        """Generate init/exit for kernel module harness"""
        return '''
/**
 * Kernel module initialization
 */
static int __init harness_module_init(void) {
    printk(KERN_INFO "kAFL Harness: Initializing\\n");

    if (harness_init() != 0) {
        printk(KERN_ERR "kAFL Harness: Initialization failed\\n");
        return -1;
    }

    printk(KERN_INFO "kAFL Harness: Ready for fuzzing\\n");

    // Main fuzzing loop
    while (1) {
        kAFL_hypercall(HYPERCALL_KAFL_NEXT_PAYLOAD, 0);
        uint32_t payload_size = kAFL_hypercall(HYPERCALL_KAFL_GET_PAYLOAD_SIZE, 0);

        harness_fuzz(payload_buffer, payload_size);

        kAFL_hypercall(HYPERCALL_KAFL_RELEASE, 0);
    }

    return 0;
}

/**
 * Kernel module cleanup
 */
static void __exit harness_module_exit(void) {
    printk(KERN_INFO "kAFL Harness: Exiting\\n");
}

module_init(harness_module_init);
module_exit(harness_module_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Binary Ninja MCP");
MODULE_DESCRIPTION("kAFL Fuzzing Harness");

void kafl_panic_handler(void) {
    kAFL_hypercall(HYPERCALL_KAFL_PANIC, iteration_count);
}
'''

    def _generate_types_header(self, config: HarnessConfig) -> str:
        """Generate header file with input structure definitions"""
        spec = config.input_spec

        if not spec.structure:
            return ""

        struct_def = self._build_c_struct(spec.structure)

        return f'''/*
 * Input type definitions
 * Auto-generated from binary analysis
 */

#ifndef INPUT_TYPES_H
#define INPUT_TYPES_H

#include <stdint.h>

{struct_def}

#endif // INPUT_TYPES_H
'''

    def _build_c_struct(self, fields: List[StructField]) -> str:
        """Convert StructField list to C struct definition"""
        lines = ["typedef struct {"]

        for field in fields:
            lines.append(f"    {field.type_str} {field.name};  // offset: {hex(field.offset)}, size: {field.size}")

        lines.append("} input_struct;")

        return '\n'.join(lines)

    def _generate_kafl_user_header(self, config: HarnessConfig) -> str:
        """Generate kAFL user API header"""
        return '''/*
 * kAFL User-Space API
 * Hypercall interface for communication with kAFL fuzzer
 */

#ifndef KAFL_USER_H
#define KAFL_USER_H

#include <stdint.h>

// kAFL hypercall numbers
#define HYPERCALL_KAFL_ACQUIRE             0
#define HYPERCALL_KAFL_RELEASE             1
#define HYPERCALL_KAFL_SUBMIT_CR3          2
#define HYPERCALL_KAFL_SUBMIT_PANIC        3
#define HYPERCALL_KAFL_SUBMIT_KASAN        4
#define HYPERCALL_KAFL_GET_PAYLOAD         5
#define HYPERCALL_KAFL_GET_PAYLOAD_SIZE    6
#define HYPERCALL_KAFL_NEXT_PAYLOAD        7
#define HYPERCALL_KAFL_RANGE_SUBMIT        8
#define HYPERCALL_KAFL_PANIC               9

// Hypercall instruction (x86-64)
static inline uint64_t kAFL_hypercall(uint32_t num, uint64_t arg) {
    uint64_t ret;
    __asm__ __volatile__(
        "vmcall"
        : "=a"(ret)
        : "a"(num), "b"(arg)
        : "memory"
    );
    return ret;
}

#endif // KAFL_USER_H
'''

    def _generate_makefile(self, config: HarnessConfig) -> str:
        """Generate Makefile for building harness"""

        if config.harness_type == HarnessType.KERNEL_MODULE:
            return '''# Makefile for kAFL Kernel Module Harness

obj-m += harness.o

KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
\t$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
\t$(MAKE) -C $(KDIR) M=$(PWD) clean

install:
\tsudo insmod harness.ko
'''
        else:
            return f'''# Makefile for kAFL Userspace Harness

CC = gcc
CFLAGS = -Wall -O2 -g
TARGET = harness

SRCS = harness.c
OBJS = $(SRCS:.c=.o)

all: $(TARGET)

$(TARGET): $(OBJS)
\t$(CC) $(CFLAGS) -o $@ $^

clean:
\trm -f $(TARGET) $(OBJS)

.PHONY: all clean
'''

    def _generate_cmake(self, config: HarnessConfig) -> str:
        """Generate CMakeLists.txt"""
        return f'''cmake_minimum_required(VERSION 3.10)
project(kafl_harness C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_FLAGS "${{CMAKE_C_FLAGS}} -Wall -O2")

add_executable(harness harness.c)

# Optional: Add sanitizers for local testing
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)
if(ENABLE_ASAN)
    target_compile_options(harness PRIVATE -fsanitize=address)
    target_link_options(harness PRIVATE -fsanitize=address)
endif()
'''

    def _generate_kafl_config(self, config: HarnessConfig) -> str:
        """Generate kAFL YAML configuration"""
        return f'''qemu:
  kernel: /path/to/vmlinuz
  initrd: /path/to/initrd.img
  mem: 2048
  extra_args:
    - -enable-kvm
    - -cpu host
    - -m 2048

harness:
  agent: ./harness
  ip0: {hex(config.target_address)}
  trace_filter: true

fuzzer:
  timeout: {config.timeout_ms}
  iterations: 0
  threads: 4
  grimoire: false
  redqueen: true
  deterministic: true

paths:
  seeds: {config.kafl_workdir}/seeds/
  workdir: {config.kafl_workdir}
  sharedir: {config.kafl_sharedir}
'''

    def _generate_readme(self, config: HarnessConfig) -> str:
        """Generate README documentation"""
        return f'''# kAFL Fuzzing Harness for {config.target_function}

Auto-generated by Binary Ninja MCP Fuzzing Extension

## Target Information

- **Function**: `{config.target_function}`
- **Address**: `{hex(config.target_address)}`
- **Harness Type**: {config.harness_type.value}
- **Input Type**: {config.input_spec.input_type}

## Building

### Userspace Harness
```bash
make
# or
cmake -B build && cmake --build build
```

### Kernel Module
```bash
make
sudo insmod harness.ko
```

## Running kAFL

1. Ensure kAFL is installed and configured
2. Place seed files in `{config.kafl_workdir}/seeds/`
3. Run the fuzzer:

```bash
./run_fuzzer.sh
```

Or manually:

```bash
kafl fuzz --config kafl.yaml
```

## Monitoring Results

```bash
# View coverage statistics
kafl plot {config.kafl_workdir}

# Replay crashes
kafl debug {config.kafl_workdir}/crashes/crash_file
```

## Customization

- Edit `harness.c` to add custom setup/cleanup logic
- Modify `kafl.yaml` to adjust fuzzing parameters
- Update `input_types.h` if input structure changes

## Generated Files

- `harness.c` - Main harness implementation
- `kafl_user.h` - kAFL API header
- `input_types.h` - Input structure definitions
- `Makefile` / `CMakeLists.txt` - Build configuration
- `kafl.yaml` - kAFL fuzzer configuration
- `run_fuzzer.sh` - Convenience script
- `setup_vm.sh` - VM setup automation
'''

    def _generate_run_script(self, config: HarnessConfig) -> str:
        """Generate shell script to run fuzzer"""
        return f'''#!/bin/bash
# kAFL Fuzzer Launch Script

set -e

WORKDIR="{config.kafl_workdir}"
CONFIG="kafl.yaml"

# Create working directory
mkdir -p "$WORKDIR/seeds"
mkdir -p "$WORKDIR/corpus"

# Check if seeds exist
if [ -z "$(ls -A $WORKDIR/seeds)" ]; then
    echo "Warning: No seeds found in $WORKDIR/seeds/"
    echo "Generating minimal seed..."
    echo -n "AAAA" > "$WORKDIR/seeds/seed_0"
fi

# Launch kAFL
echo "Starting kAFL fuzzer..."
kafl fuzz --config "$CONFIG" --workdir "$WORKDIR"
'''

    def _generate_vm_setup_script(self, config: HarnessConfig) -> str:
        """Generate VM setup automation script"""
        return '''#!/bin/bash
# VM Setup Script for kAFL Fuzzing

set -e

echo "Setting up VM for kAFL fuzzing..."

# Install dependencies
sudo apt-get update
sudo apt-get install -y build-essential linux-headers-$(uname -r)

# Build harness
make clean
make

# Load kernel module if needed
if [ -f "harness.ko" ]; then
    sudo insmod harness.ko
    echo "Kernel module loaded"
fi

# Configure system for fuzzing
echo "Configuring system..."
echo core > /proc/sys/kernel/core_pattern
echo 0 > /proc/sys/kernel/randomize_va_space  # Disable ASLR for determinism

echo "VM setup complete"
'''


def generate_harness_from_config(bv, target_name: str, input_spec_json: str,
                                 harness_type: str = "kernel") -> Dict[str, str]:
    """Convenience function to generate harness from JSON config"""

    # Parse input spec
    input_spec_dict = json.loads(input_spec_json)

    # Convert to InputSpec object (simplified - full implementation would reconstruct all fields)
    from .input_analyzer import InputSpec
    input_spec = InputSpec(
        input_type=input_spec_dict.get('input_type', 'buffer'),
        size=input_spec_dict.get('size'),
        min_size=input_spec_dict.get('min_size'),
        max_size=input_spec_dict.get('max_size'),
    )

    # Get target function
    func = None
    for f in bv.functions:
        if f.name == target_name:
            func = f
            break

    if not func:
        raise ValueError(f"Function {target_name} not found")

    # Create config
    config = HarnessConfig(
        target_function=target_name,
        target_address=func.start,
        input_spec=input_spec,
        harness_type=HarnessType(harness_type),
    )

    # Generate harness
    generator = HarnessGenerator(bv)
    return generator.generate_harness(config)
